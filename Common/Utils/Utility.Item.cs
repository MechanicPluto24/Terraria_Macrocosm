using Macrocosm.Common.Global.Items;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System;
using Terraria;
using Terraria.GameContent;
using Terraria.GameContent.Achievements;
using Terraria.GameContent.ItemDropRules;
using Terraria.ID;

namespace Macrocosm.Common.Utils;

public static partial class Utility
{
    public static CustomDrawGlobalItem CustomDrawData(this Item item) => item.GetGlobalItem<CustomDrawGlobalItem>();
    public static bool IsChest(this Item item) => TileID.Sets.BasicChest[item.createTile];

    /// <summary>
    /// Helper method that converts the first rocket ammo found in the inventory 
    /// to the projectile ID generated by rocket ammo of a vanilla launcher 
    /// (either Grenade, Rocket or Mine)
    /// </summary>
    /// <param name="player"> The player using the picked rocket ammo </param>
    /// <param name="copyWeaponType"> The launcher type to copy </param>
    /// <returns> The projectile ID, defaults to Rocket I </returns>
    public static int GetRocketAmmoProjectileID(Player player, int copyWeaponType)
    {
        if (copyWeaponType != ItemID.GrenadeLauncher && copyWeaponType != ItemID.RocketLauncher && copyWeaponType != ItemID.ProximityMineLauncher)
            return ProjectileID.RocketI;

        Item launcher = new(copyWeaponType);
        Item ammo = player.ChooseAmmo(launcher);

        if (ammo is null)
            return 0;

        int type;

        static bool TryFindingSpecificMatches(int launcher, int ammo, out int pickedProjectileId)
        {
            pickedProjectileId = 0;
            if (AmmoID.Sets.SpecificLauncherAmmoProjectileMatches.TryGetValue(launcher, out var value) && value.TryGetValue(ammo, out pickedProjectileId)) return true;
            launcher = AmmoID.Sets.SpecificLauncherAmmoProjectileFallback[launcher];
            return launcher != -1 && AmmoID.Sets.SpecificLauncherAmmoProjectileMatches.TryGetValue(launcher, out var fallbackValue) && fallbackValue.TryGetValue(ammo, out pickedProjectileId);
        }

        if (TryFindingSpecificMatches(copyWeaponType, ammo.type, out int pickedProjectileId)) // for mini nukes, liquid rockets
            type = pickedProjectileId;
        else if (ammo.ammo == AmmoID.Rocket) // for rockets I to IV
            type = launcher.shoot + ammo.shoot;
        else
            type = ProjectileID.RocketI;

        return type;
    }

    public static void DecreaseStack(this Item item, int amount = 1)
    {
        item.stack -= amount;
        if (item.stack < 1 || item.type == ItemID.None)
            item.TurnToAir(fullReset: true);
    }

    public static bool TryPlaceItemInChest(ref Item item, Chest targetChest, bool justCheck, bool serverSync = true)
    {
        if (item.IsAir || item.stack <= 0)
            return false;

        bool placed = false;
        bool shouldSync = Main.netMode == NetmodeID.MultiplayerClient || (serverSync && Main.netMode == NetmodeID.Server);

        for (int i = 0; i < targetChest.item.Length; i++)
        {
            Item chestItem = targetChest.item[i];

            if (chestItem.stack > 0 && chestItem.type == item.type)
            {
                int transferableAmount = Math.Min(item.stack, chestItem.maxStack - chestItem.stack);

                if (transferableAmount > 0)
                {
                    if (justCheck)
                        return true;

                    chestItem.stack += transferableAmount;
                    item.stack -= transferableAmount;
                    placed = true;

                    if (shouldSync)
                    {
                        int chestIndex = Chest.FindChest(targetChest.x, targetChest.y);
                        NetMessage.SendData(MessageID.SyncChestItem, -1, -1, null, chestIndex, i);
                    }

                    if (item.stack <= 0)
                    {
                        item.TurnToAir();
                        break;
                    }
                }
            }
        }

        if (item.stack > 0)
        {
            for (int i = 0; i < targetChest.item.Length; i++)
            {
                if (targetChest.item[i].IsAir)
                {
                    if (justCheck)
                        return true;

                    targetChest.item[i] = item.Clone();
                    item.TurnToAir();
                    placed = true;

                    if (shouldSync)
                    {
                        int chestIndex = Chest.FindChest(targetChest.x, targetChest.y);
                        NetMessage.SendData(MessageID.SyncChestItem, -1, -1, null, chestIndex, i);
                    }

                    break;
                }
            }
        }

        return placed;
    }


    public static void AddVariationToRubblemakers(int itemType, int tileType, int tileStyle)
    {
        FlexibleTileWand.RubblePlacementSmall.AddVariation(itemType, tileType, tileStyle);
        FlexibleTileWand.RubblePlacementMedium.AddVariation(itemType, tileType, tileStyle);
        FlexibleTileWand.RubblePlacementLarge.AddVariation(itemType, tileType, tileStyle);
    }

    public static void AddVariationsToRubblemakers(int itemType, int tileType, params int[] tileStyles)
    {
        FlexibleTileWand.RubblePlacementSmall.AddVariations(itemType, tileType, tileStyles);
        FlexibleTileWand.RubblePlacementMedium.AddVariations(itemType, tileType, tileStyles);
        FlexibleTileWand.RubblePlacementLarge.AddVariations(itemType, tileType, tileStyles);
    }

    public static void AddVariationsToRubblemakers(int itemType, int tileType, Range tileStyles)
    {
        FlexibleTileWand.RubblePlacementSmall.AddVariations(itemType, tileType, tileStyles);
        FlexibleTileWand.RubblePlacementMedium.AddVariations(itemType, tileType, tileStyles);
        FlexibleTileWand.RubblePlacementLarge.AddVariations(itemType, tileType, tileStyles);
    }

    public static void Shimmer(this Item item, int targetType)
    {
        int originalStack = item.stack;

        item.SetDefaults(targetType);
        item.shimmered = true;
        item.stack = originalStack;
        item.shimmerTime = item.stack > 0 ? 1f : 0f;
        item.shimmerWet = true;
        item.wet = true;
        item.velocity *= 0.1f;

        if (Main.netMode == NetmodeID.SinglePlayer)
        {
            Item.ShimmerEffect(item.Center);
        }
        else
        {
            NetMessage.SendData(MessageID.ShimmerActions, -1, -1, null, 0, (int)item.Center.X, (int)item.Center.Y);
            NetMessage.SendData(MessageID.SyncItemsWithShimmer, -1, -1, null, item.whoAmI, 1f);
        }

        AchievementsHelper.NotifyProgressionEvent(AchievementHelperID.Events.TransmuteItem);

        if (item.stack == 0)
        {
            item.makeNPC = -1;
            item.active = false;
        }
    }


    public static void DrawBossBagEffect(this Item item, SpriteBatch spriteBatch, Color colorFront, Color colorBack, float rotation, float scale)
    {
        Texture2D texture = TextureAssets.Item[item.type].Value;
        Rectangle frame = texture.Frame();

        Vector2 frameOrigin = frame.Size() / 2f;
        Vector2 offset = new(item.width / 2 - frameOrigin.X, item.height - frame.Height);
        Vector2 drawPos = item.position - Main.screenPosition + frameOrigin + offset;

        float time = Main.GlobalTimeWrappedHourly;
        float timer = item.timeSinceItemSpawned / 240f + time * 0.04f;

        time %= 4f;
        time /= 2f;

        if (time >= 1f)
            time = 2f - time;

        time = time * 0.5f + 0.5f;

        for (float i = 0f; i < 1f; i += 0.25f)
        {
            float radians = (i + timer) * MathHelper.TwoPi;
            spriteBatch.Draw(texture, drawPos + new Vector2(0f, 8f).RotatedBy(radians) * time, frame, colorFront, rotation, frameOrigin, scale, SpriteEffects.None, 0);
        }

        for (float i = 0f; i < 1f; i += 0.34f)
        {
            float radians = (i + timer) * MathHelper.TwoPi;
            spriteBatch.Draw(texture, drawPos + new Vector2(0f, 4f).RotatedBy(radians) * time, frame, colorBack, rotation, frameOrigin, scale, SpriteEffects.None, 0);
        }
    }

    public static void GetInfoText(this DropRateInfo dropRateInfo, bool locked, out string stackRange, out string dropRate)
    {
        if (dropRateInfo.stackMin != dropRateInfo.stackMax)
            stackRange = $"({dropRateInfo.stackMin}-{dropRateInfo.stackMax})";
        else if (dropRateInfo.stackMin == 1)
            stackRange = "";
        else
            stackRange = "(" + dropRateInfo.stackMin + ")";

        string originalFormat = "P";
        if (dropRateInfo.dropRate < 0.001)
            originalFormat = "P4";

        if (dropRateInfo.dropRate != 1f)
            dropRate = Terraria.Utils.PrettifyPercentDisplay(dropRateInfo.dropRate, originalFormat);
        else
            dropRate = "100%";

        if (locked)
        {
            dropRate = "???";
            stackRange = "";
        }
    }

    public static float ComputeDropRarity(this DropRateInfo dropRateInfo)
    {
        float averageStack = (dropRateInfo.stackMin + dropRateInfo.stackMax) / 2f;
        float rarity = (1f - dropRateInfo.dropRate) * (1f / (averageStack + 1f));
        return rarity;
    }

    public static int GetItemTypeFromWingID(int wingID)
    {
        foreach (var kvp in ContentSamples.ItemsByType)
        {
            int type = kvp.Key;
            Item item = kvp.Value;

            if (item.wingSlot == wingID)
                return type;
        }

        return -1;
    }

    public static void SimulateGuideVoodooDollBurn(Vector2 position)
    {
        int index = Item.NewItem(Item.GetSource_None(), new Rectangle((int)position.X, (int)position.Y, 1, 1), ItemID.GuideVoodooDoll, Stack: 1, noBroadcast: true);
        typeof(Item).InvokeMethod("CheckLavaDeath", Main.item[index], parameters: [index]);
    }
}
